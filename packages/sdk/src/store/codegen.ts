import {
  GraphQLEnumType,
  GraphQLInterfaceType,
  GraphQLList,
  GraphQLNonNull,
  GraphQLObjectType,
  GraphQLOutputType,
  GraphQLScalarType,
  GraphQLSchema,
  isEnumType,
  isListType,
  isNonNullType
} from 'graphql'
import * as fs from 'node:fs'
import path from 'path'
import { mkdirpSync } from 'mkdirp'
import { schemaFromFile } from './schema.js'
import chalk from 'chalk'

interface Import {
  module: string
  types: string[]
  importType?: boolean
}

interface Field {
  name: string
  type: string
  optional?: boolean
  annotations: string[]
}

interface Class {
  name: string
  fields: Field[]
  annotations: string[]
  parent?: string
  interfaces: string[]
}

interface Interface {
  name: string
  fields: Field[]
}

interface Enum {
  name: string
  values: string[]
}

export async function codegen(srcDir: string, outputDir: string) {
  for (const file of fs.readdirSync(srcDir)) {
    const f = path.join(srcDir, file)
    const filePath = path.parse(f)
    if (filePath.ext == '.graphql') {
      const { schema, source } = schemaFromFile(f)
      const target = path.join(outputDir, filePath.name + '.ts')
      await codegenInternal(schema, source, target)
      console.log(chalk.green(`Generated ${target}`))
    }
  }
}

function addTypeAnnotations(ty: GraphQLOutputType, annotations: string[]) {
  if (isNonNullType(ty)) {
    annotations.push('@Required')
    addTypeAnnotations(ty.ofType, annotations)
    return
  }

  if (isRelationType(ty)) {
    if (isListType(ty)) {
      annotations.push(`@Many("${ty.ofType}")`)
    } else {
      annotations.push(`@One("${ty}")`)
    }
  } else if (isEnumType(ty)) {
    annotations.push(`@Column("String${isNonNullType(ty) ? '!' : ''}")`)
  } else {
    if (isListType(ty)) {
      if (isListType(ty.ofType)) {
        annotations.push(`@ListColumn()`)
        addTypeAnnotations(ty.ofType, annotations)
      } else {
        annotations.push(`@ListColumn("${ty.ofType}")`)
      }
    } else {
      annotations.push(`@Column("${ty}")`)
    }
  }
}

async function codegenInternal(schema: GraphQLSchema, source: string, target: string) {
  const imports: Import[] = [
    {
      module: '@sentio/sdk/store',
      types: ['String', 'Int', 'BigInt', 'Float', 'ID', 'Bytes', 'Timestamp', 'Boolean'],
      importType: true
    },
    {
      module: '@sentio/sdk/store',
      types: ['Entity', 'Required', 'One', 'Many', 'Column', 'ListColumn', 'AbstractEntity']
    },
    {
      module: '@sentio/bigdecimal',
      types: ['BigDecimal']
    },
    {
      module: '@sentio/sdk',
      types: ['DatabaseSchema']
    }
  ]
  const enums: Enum[] = []
  const interfaces: Interface[] = []
  const classes: Class[] = []

  for (const t of Object.values(schema.getTypeMap())) {
    if (t.name.startsWith('__')) {
      continue
    }
    if (t instanceof GraphQLEnumType) {
      enums.push({
        name: t.name,
        values: t.getValues().map((v) => v.value)
      })
    }
    if (t instanceof GraphQLInterfaceType) {
      interfaces.push({
        name: t.name,
        fields: Object.values(t.getFields()).map((f) => ({
          name: f.name,
          type: genType(f.type),
          annotations: []
        }))
      })
    }
  }

  for (const t of Object.values(schema.getTypeMap())) {
    if (t.name.startsWith('__')) {
      continue
    }

    if (t instanceof GraphQLObjectType) {
      if (isEntity(t)) {
        const fields: Field[] = []
        for (const f of Object.values(t.getFields())) {
          const type = genType(f.type)
          const annotations: string[] = []
          addTypeAnnotations(f.type, annotations)
          if (isRelationType(f.type)) {
            fields.push({
              name: f.name,
              type: `Promise<${type}>`,
              annotations
            })
            const isMany = type.startsWith('Array')
            fields.push({
              name: f.name + 'ID' + (isMany ? 's' : ''),
              type: isMany ? `Array<ID | undefined>` : `ID`,
              annotations: []
            })
          } else {
            fields.push({
              name: f.name,
              optional: !f.type.toString().endsWith('!'),
              type: type.replace(' | undefined', ''),
              annotations
            })
          }
        }
        classes.push({
          name: t.name,
          fields,
          annotations: [`@Entity("${t.name}")`],
          parent: 'AbstractEntity',
          interfaces: t.getInterfaces().map((i) => i.name)
        })
      } else {
        classes.push({
          name: t.name,
          fields: Object.values(t.getFields()).map((f) => ({
            name: f.name,
            optional: !f.type.toString().endsWith('!'),
            type: genType(f.type).replace(' | undefined', ''),
            annotations: []
          })),
          annotations: [],
          interfaces: t.getInterfaces().map((i) => i.name)
        })
      }
    }
  }

  const template = `
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
${imports.map((i) => `import ${i.importType ? 'type ' : ''}{ ${i.types.join(', ')} } from '${i.module}'`).join('\n')}

${enums
  .map(
    (e) => `export enum ${e.name} {
  ${e.values.map((v) => `${v} = "${v}"`).join(', ')}
}`
  )
  .join('\n')}

${interfaces
  .map(
    (i) => `export interface ${i.name} {
  ${i.fields.map((f) => `\t${f.name}: ${f.type}`).join('\n')}
}`
  )
  .join('\n')}

${classes
  .map(
    (c) => `
${c.annotations.join('\n')}
export class ${c.name} ${c.parent ? `extends ${c.parent}` : ''} ${c.interfaces.length > 0 ? `implements ${c.interfaces.join(', ')}` : ''} {
${c.fields
  .map((f) => `${f.annotations.map((a) => `\n\t${a}`).join('')}\n\t${f.name}${f.optional ? '?' : ''}: ${f.type}`)
  .join('\n')}
  ${c.annotations.some((a) => a.startsWith('@Entity')) ? `constructor(data: Partial<${c.name}>) {super()}` : ''}
}`
  )
  .join('\n')}
`

  const contents =
    template +
    `\n
const source = \`${source.replaceAll('`', '`')}\`
DatabaseSchema.register({
  source,
  entities: {
    ${classes.map((e) => `"${e.name}": ${e.name}`).join(',\n\t\t')}
  }
})
`
  mkdirpSync(path.dirname(target))

  fs.writeFileSync(target, contents)
}

function genType(type: GraphQLOutputType, required?: boolean): string {
  if (type instanceof GraphQLNonNull) {
    return genType(type.ofType, true)
  } else if (type instanceof GraphQLScalarType) {
    return required ? type.name : `${type.name} | undefined`
  } else if (type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType) {
    return required ? type.name : `${type.name} | undefined`
  } else if (type instanceof GraphQLList) {
    return `Array<${genType(type.ofType)}>`
  } else if (type instanceof GraphQLEnumType) {
    return required ? type.name : `${type.name} | undefined`
  } else {
    throw new Error('Unsupported type: ' + type)
  }
}

function isRelationType(type: GraphQLOutputType): boolean {
  if (type instanceof GraphQLNonNull) {
    return isRelationType(type.ofType)
  } else if (type instanceof GraphQLObjectType || type instanceof GraphQLInterfaceType) {
    return true
  } else if (type instanceof GraphQLList) {
    return isRelationType(type.ofType)
  } else {
    return false
  }
}

function isEntity(t: GraphQLObjectType) {
  return t.astNode?.directives?.some((d) => d.name.value == 'entity')
}
